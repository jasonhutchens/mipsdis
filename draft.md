# Mipsdis

`mipsdis` is a MIPS bytecode disassembler that I've been hacking on that uses
code generation (aka metaprogramming).

I wrote `mipsdis` because I'm interested in low-level software like emulators
and kernels, and getting to grips with an ISA has been on my list for a while.
As far as that goes, I thought writing a disassembler would be a good first
step.

I picked MIPS because it is very simple and regular, and is small enough to fit
in your head. I reckon that x86 would take me ten times as long, and ARM
probably comes with a bunch of baggage.

I decided to use metaprogramming for a few reasons.

Firstly, I find writing a bunch of slightly different dispatch and decoding
routines by hand is tedious and error-prone. I find manipulating metadata using
a simple, commented text format to be much more pleasant.

Secondly, I wanted both a C version of the disassembler that I could use on the
command line as a filter, and a javascript version that would be easy to share
and demonstrate.

Finally, I also wanted to use the metadata and code generation for some other
low-level projects that I am working on.

This article will demonstrate the different versions of the disassembler,
discuss the code generator, describe how to extend mipsdis, tell you how to get
the code and run it and then conclude by describing some of the extra
documentation available for the project.

You should find this article and project of use if you are hacking on stuff to
do with MIPS, or have ever wanted to write an assembler, disassembler or
 emulator.

# Demo

There are four parts to mipsdis that can be demonstrated.

The first is a javascript version that runs in the browser which you can try
out below. The data in the input textarea consists of the program counter in
hex followed by the MIPS opcode. It is a similar format to that used by
objdump.

If you click disassemble, the browser will disassemble the program and show the
MIPS mnemonic and operands in the output textarea.

The default program shown is a fragment of a hello world binary. The program
uses a loop to load a byte from the C string "hello world" and store it to a
memory location that will cause it to be output to the console.

Click [here](http://blog.loadzero.com/draft/mipsdis.html) for that.

The second part is a C version of mipsdis that runs on the command line. An
example using the same program as above is shown below:

    $ ./bin/mipsdis test/hello.txt

    80001000:	3c048000	lui $4,0x8000
    80001004:	34844000	ori $4,$4,0x4000
    80001008:	3c05b400	lui $5,0xb400
    8000100c:	34a503f8	ori $5,$5,0x3f8
    80001010:	80860000	lb $6,0($4)
    80001014:	10c00005	beq $6,$0,0x8000102c
    80001018:	00000000	sll $0,$0,0x0
    8000101c:	a0a60000	sb $6,0($5)
    80001020:	24840001	addiu $4,$4,1
    80001024:	08000404	j 0x80001010
    80001028:	00000000	sll $0,$0,0x0
    8000102c:	3c05bfbf	lui $5,0xbfbf
    80001030:	34a50004	ori $5,$5,0x4
    80001034:	3c060000	lui $6,0x0
    80001038:	34c6002a	ori $6,$6,0x2a
    8000103c:	a0a60000	sb $6,0($5)

The other two parts are ruby and javascript versions of mipsdis, which can be run as shown below.

ruby:

    $ ./bin/mipsdis.rb test/hello.txt

    80001000:	3c048000	lui $4,0x8000
    ...

javascript:

    $ nodejs ./bin/mipsdis.js test/hello.txt

    80001000:	3c048000	lui $4,0x8000
    ...

# Mipsgen

I wrote a ruby script called [mipsgen](scripts/mipsgen.rb) to do the heavy
lifting of generating the core routines for each version of the disassembler.

The metadata used by mipsgen was created by a process of reading the
architecture manuals and then compiling the information on each mnemonic into a
form that makes sense for both humans and machines.

The manuals are listed below:

1. [MIPS32 4K User's manual](https://imagination-technologies-cloudfront-assets.s3.amazonaws.com/documentation/MD00016-2B-4K-SUM-01.18.pdf)
2. [MIPS32 Architecture for Programmers Vol 2](http://www.cs.cornell.edu/courses/cs3410/2015sp/MIPS_Vol2.pdf)

The metadata compilation is contained in these files:

[tables/dispatch_tables](tables/dispatch_tables.txt) is used to drive decoder switch statements.  
[tables/opcode_bits.txt](tables/opcode_bits.txt) specifies the bitwise layout of each opcode.  
[tables/asm_format.txt](tables/asm_format.txt) specifies the human readable format of each mnemonic.  
[tables/field_format.txt](tables/field_format.txt) specifies the printf format of fields inside `asm_format`.  

`mipsgen` parses this data, and then hands it off to specific code generation
routines that generate the appropriate switch statements and formatting code
for each language.

This keeps the amount of language specific code for each disassembler down to
around 300 lines. The amount of autogenerated code is around 1300 lines for
each version (C, ruby, javascript).

# Extending mipsdis

Adding support for another language such as python to the code generator would
be straightforward, you would have to do something like this:

- Copy mipsdis/rbgen.rb to mipsdis/pygen.rb
- Adjust the method names accordingly
- Modify the print statements in `py_emit_decoder` and `py_gen_switch` to emit
  the appropriate python code.
- Port disasm/rb/mipsdis.rb to disasm/py/mipsdis.py. This is mostly a matter of
  tweaking the bitwise field extraction routines to make the semantics correct
  for python.

Adding new opcodes would be a bit harder, depending on how complex they are. You would have to do something like this:

- Add the correct entry to [tables/dispatch_tables.txt](tables/dispatch_tables.txt)
- Add the bitwise layout of the opcode to [tables/opcode_bits.txt](tables/opcode_bits.txt)
- Add the format of the command to [tables/asm_format.txt](tables/asm_format.txt) and [tables/field_format.txt](tables/field_format.txt)
- If the new opcode introduces new fields or a new interpretation of those
  fields, new field_xxx and getxxx functions will have to be added. See field_m
  and getbroff in [disasm/c/mipsdis.c](disasm/c/mipsdis.c) for details.

# Building

To get the source and run it:

    git clone https://github.com/loadzero/mipsdis.git && cd mipsdis
    ./configure.sh
    make
    make test

The configure script will check for these dependencies:

- make
- ruby
- nodejs (optional)

`nodejs` is an optional dependency that is used only to test the autogenerated
javascript code. If it is not found, then that test is skipped. I did not
really feel like adding it as a hard dependency.

The code is tested by running [test/input.txt](test/input.txt) through each
disassembler and ensuring that [test/expected.txt](test/expected.txt) is the
result.

The test input was generated by a fuzzer script that uses
[tables/opcode_bits.txt](tables/opcode_bits.txt) and [tables/dispatch_tables.txt](tables/dispatch_tables.txt) to generate test cases.

# Documentation

Apart from this post, there are a few bits and pieces of documentation in the
codebase that are worth looking at.

There is an outline of the code in [outline.md](outline.md), in topological
order, that contains a summary of each module.

Each file in the codebase has (or should have) a fairly verbose description of
what it is and why it exists at the top of the file. This description will
contain cross references to other parts of the codebase where necessary.

There is some more documentation on the code generation, as well as a static
copy of the auto generated code inside the `docs/` directory.

See [docs/cgen.md](docs/cgen.md) for the C version.  
See [docs/jsgen.md](docs/jsgen.md) for the javascript version.  
See [docs/rbgen.md](docs/rbgen.md) for the ruby version.  
