# This file contains the C code generator for mipsgen.
#
# See scripts/mipsgen.rb for the caller of this code.
# See disasm/rb/mipsdis.rb for the disassembler that hosts the generated code.
# See docs/cgen.md for more info.

# The argument list for C decode_xxx prototypes.
$cargs_proto = "char *outbuf, size_t n, uint32_t pc, uint32_t op";

# The argument list for calling C decode_xxx functions.
$cargs = "outbuf, n, pc, op";

# Print the comment header to stdout.
def c_generate_comment_header
puts <<HERE
/*
 * This file contains autogenerated routines for dispatching and disassembling
 * MIPS opcodes.
 *
 * The code has been generated by mipsgen.
 *
 * See scripts/mipsgen.rb for the code generator framework.
 * See codegen/cgen.rb for C specific information.
 */

HERE
end

# Builds the format string used by snprintf in the generated decoder function.
# The metadata for this is in tables/asm_format.txt and tables/field_format.txt.
def c_build_format_string(mne, tokens, field_format)
    fmt_a = []

    tokens.each{|t|
        if (field_format.include?(t))
            fmt_a << field_format[t][0]
        else
            fmt_a << t
        end
    }

    fmt_s = mne

    if (!fmt_a.empty?)
        fmt_s += ' ' + fmt_a.join
    end

    return '"' + fmt_s + '"'
end

# Builds the arguments for the format string built by c_build_format_string.
def c_build_args(mne, tokens, field_format)
    args_a = []

    tokens.each{|t|

        if (field_format.include?(t))
            pc = field_format[t][1]
            field_args = pc ? "pc,op" : "op"
            args_a << "get#{t}(#{field_args})"
        end
    }

    return args_a
end

# Builds the error checks required for a decoder.
# Every opcode has its bitmask checked against a comparison value.
# Some opcodes (cl, jalr) require extra checking.
# The metadata for this is in tables/opcode_bits.txt.
def c_build_error_checks(mne, bitmasks)
    mask = bitmasks[mne]['mask']
    value = bitmasks[mne]['value']
    has_reserved = bitmasks[mne]['reserved']

    checks = []

    if (has_reserved)
        checks << "check_opcode(op, #{mask}, #{value})"
    end

    if (mne =~ /^cl/)
        checks << 'check_cl(getrt(op), getrd(op))'
    end

    if (mne =~ /^jalr/)
        checks << "check_jalr(getrs(op), getrd(op))"
    end

    return checks
end

# Emits the generated decoder to stdout.
def c_emit_decoder(mne, checks, fmt, args)
    spargs = ['outbuf', 'n', fmt] + args

    puts "static void decode_#{mne}(#{$cargs_proto})"
    puts "{"

    if (!checks.empty?)

    puts "    if (!(#{checks.join("&&")}))"
    puts "    {"
    puts "        decode_illegal(outbuf, n, pc, op);"
    puts "        return;"
    puts "    }"
    puts ""

    end

    puts "    snprintf(#{spargs.join(',')});"
    puts "}"
    puts ""
end


# Generate all decoders.
def c_generate_decoders(asm_format, field_format, bitmasks)
    asm_format.each{|k,toks|

        fmt = c_build_format_string(k, toks, field_format)
        args = c_build_args(k, toks, field_format)
        checks = c_build_error_checks(k, bitmasks)
  
        c_emit_decoder(k, checks, fmt, args)
    }
end

# Generate the prototypes for all decoders.
def c_generate_proto(tables)
    tables.each{|k,v|
        puts "static void decode_#{k}(#{$cargs_proto});"
    }
end

# Generate a dispatcher function by generating a switch statement that calls
# the correct decoding routines.
#
# The metadata for this is in tables/dispatch_tables.txt.
def c_gen_dispatcher(name, field, groups)

    puts "static void decode_#{name}(#{$cargs_proto})"
    puts "{"
    puts "    switch (get#{field}(op))"
    puts "    {"

    groups.each{|grp,vals|
        vals.each{|v|
    puts "        case #{v}:"
        }
    puts "            decode_#{grp}(#{$cargs});"
    puts "            break;"
        }

    puts "        default:"
    puts "            /* unreachable */"
    puts "            abort();"
    puts "    }"
    puts "}"
    puts ""
end

# Generate all the dispatcher functions.
def c_generate_dispatchers(tables)
    tables.each{|k, v|
        c_gen_dispatcher(k, v['field'], v['groups'])
    }
end

# Generate all the code necessary for the C version disassembler.
def c_generate(gen_info)

    asm_format = gen_info['asm_format']
    field_format = gen_info['field_format']

    bitmasks = gen_info['bitmasks']
    tables = gen_info['dispatch_tables']

    c_generate_comment_header()
    c_generate_decoders(asm_format, field_format, bitmasks)
    c_generate_proto(tables)
    c_generate_dispatchers(tables)
end
