#!/usr/bin/env ruby

# mipsdis is a simple ruby-based command line MIPS disassembler. The core
# dispatch and decoding routines are autogenerated by mipsgen.
#
# usage:
#     mipsdis input.txt
#
# The expected input format is the first two columns from objdump:
#
#     hex_addr   hex_opcode
#     80001678:  27bd0008
#
# The decoder will ignore any extra columns, and any lines not matching the
# above format.
#
# The output format is similar to objdump output:
#
#     hex_addr   hex_opcode  asm
#     80001678:  27bd0008    addiu  $29,$29,8
#
# This is not a fully featured disassembler, as it lacks quite a few
# usability features, but it is sufficient for debugging and exercising the
# code generator.
#
# See codegen/rbgen.rb for more information.
$:.unshift(File.expand_path("../../disasm/rb", __FILE__))

require 'pp'
Signal.trap("PIPE", "EXIT")

# The field_xxx functions provide raw access to the bits denoted by code
# letter in the 'opcode_bits' file.
#
# They are not responsible for interpretation, they just pick out the right
# bits and shift them. Ruby will return these as positve integers.
def field_m(op)
  (op & 0xfc000000) >> 26
end

def field_u(op)
  (op & 0x0000003f)
end

def field_s(op)
  (op & 0x03e00000) >> 21
end

def field_t(op)
  (op & 0x001f0000) >> 16
end

def field_o(op)
  (op & 0x0000ffff)
end

def field_i(op)
  (op & 0x0000ffff)
end

def field_b(op)
  (op & 0x03e00000) >> 21
end

def field_p(op)
  (op & 0x001f0000) >> 16
end

def field_f(op)
  (op & 0x001f0000) >> 16
end

def field_d(op)
  (op & 0x0000f800) >> 11
end

def field_a(op)
  (op & 0x000007c0) >> 6
end

def field_c(op)
  (op & 0x03ffffc0) >> 6
end

def field_y(op)
  (op & 0x000007c0) >> 6
end

def field_e(op)
  (op & 0x0000ffc0) >> 6
end

def field_n(op)
  (op & 0x00000007)
end

def field_x(op)
  (op & 0x03ffffff)
end

def field_z(op)
  (op & 0x01ffffc0) >> 6
end

# Top 10 bits of syscode.
def field_bc1(op)
  (op & 0x03ff0000) >> 16
end

# Bottom 10 bits of syscode.
def field_bc2(op)
  (op & 0x0000ffc0) >> 6
end

# The getxxx functions interpret the results returned by field_xxx and any
# extra arithmetic or sign handling is done here
def getopcode(op)
  field_m(op)
end

def getfunction(op)
  field_u(op)
end

def getrt(op)
  field_t(op)
end

def getrs(op)
  field_s(op)
end

def getrd(op)
  field_d(op)
end

# Compute the jump target address (used in j, jal).
def gettarget(pc, op)
  x = field_x(op)
  hibits = (pc + 4) & 0xf0000000
  lobits = x << 2

  (hibits | lobits)
end

# Compute the branch offset (used in beq, bne, etc).
def getbroff(pc, op)
  # o is sign extended to 18 bits

  o = field_o(op) << 2
  m = 1 << (18 - 1)
  r = (o ^ m) - m;

  (pc + 4) + r
end

# Get the immediate field as a signed 16 bit quantity.
def getsimm(op)
  o = field_o(op);
  m = 1 << (16 - 1);

  (o ^ m) - m;
end

def getimm(op)
  field_i(op)
end

def getoffset(op)
  getsimm(op)
end

def getbase(op)
  field_b(op)
end

def getcacheop(op)
  field_p(op)
end

def getprefhint(op)
  field_f(op)
end

def getsa(op)
  field_a(op)
end

def getbc1(op)
  field_bc1(op)
end

def getbc2(op)
  field_bc2(op)
end

def getsyscode(op)
  field_c(op)
end

def getstype(op)
  field_y(op)
end

def gettrapcode(op)
  field_e(op)
end

def getsel(op)
  field_n(op)
end

def getwaitcode(op)
  field_z(op)
end

# Instruction validation functions.
# Returns true for OK, false otherwise.
def check_opcode(op, mask, value)
  (op & mask) == value
end

def check_cl(rt, rd)
  rt == rd
end

def check_jalr(rs, rd)
  rs != rd
end

# Handle illegal and reserved opcodes.
def decode_unusable(pc, op)
    return 'illegal'
end

def decode_reserved(pc, op)
    return 'illegal'
end

require 'mips_dispatch.rb'

def decode(address, opcode)
  decode_OPCODE(address, opcode)
end

# Determines if a string is a valid address.
def is_addr(s)
  s.match(/^[0-9a-fA-F]+:$/) != nil
end

# Determines if a string is a valid hexword.
def is_hexword(s)
  s.match(/^[0-9a-fA-F]{8}$/) != nil
end

# Convert a string containing hex chars to a positive integer.
def hex_to_u32(s)
  s.hex
end

# For each line in the stream, pass it through the decoder and output
# address, opcode and disasm to stdout
def decode_stream(stream)
  stream.each_line{|l|
    toks = l.split(/[ \t\r]/)
    next unless toks.length >= 2

    addrtok, optok = toks
    next unless is_addr(addrtok) && is_hexword(optok)

    address = hex_to_u32(addrtok)
    opcode = hex_to_u32(optok)

    out = decode(address, opcode)
    printf("%08x:\t%08x\t%s\n", address, opcode, out)
  }
end

def main()
  decode_stream(ARGF)
end

main()
